# Phase 2 单元3 - AI对话系统 产品规划文档

**文档版本**: v1.0
**创建日期**: 2025-10-03
**负责人**: BMad Orchestrator
**项目阶段**: Phase 2 Unit 3

---

## 📋 目录

1. [产品愿景](#产品愿景)
2. [核心价值](#核心价值)
3. [用户场景](#用户场景)
4. [功能规划](#功能规划)
5. [技术架构](#技术架构)
6. [MVP范围](#mvp范围)
7. [开发计划](#开发计划)
8. [成功指标](#成功指标)
9. [风险评估](#风险评估)

---

## 🎯 产品愿景

### 一句话描述
> 将视频理解引擎的结构化数据，转化为可对话的智能知识助手，让用户通过自然语言探索视频内容。

### 设计理念
- **降低门槛**: 从"查询语法"到"自然对话"
- **智能关联**: 跨维度连接视频中的知识点
- **创作赋能**: 快速定位和评估可复用素材
- **上下文感知**: 支持多轮对话的连贯体验

---

## 💡 核心价值

### 对用户的价值
| 用户类型 | 核心需求 | 解决方案 |
|---------|---------|---------|
| **内容创作者** | 快速找到可复用的精彩片段 | 语义搜索 + 创作角度推荐 |
| **研究者** | 探索视频中的知识关系 | 知识图谱查询 + 实体关联 |
| **学习者** | 快速理解视频核心内容 | 智能摘要 + 重点提取 |
| **运营人员** | 评估内容质量和完整性 | 质量分析 + 结构化报告 |

### 对系统的价值
- **盘活数据**: 现有6类结构化数据（原子/片段/实体/主题/图谱/创作角度）从"静态文件"变为"活跃知识库"
- **闭环体验**: 从"视频处理→数据生成"到"数据查询→洞察发现"的完整闭环
- **差异化**: 相比普通视频搜索，提供语义级、关系级、创作级的深度查询

---

## 👥 用户场景

### 场景1: 素材挖掘（内容创作者）

**用户故事**:
> 作为一名短视频创作者，我想快速找到长视频中适合做短视频的精彩片段，以便高效复用内容。

**对话示例**:
```
👤 用户: "这个视频有哪些适合做抖音短视频的片段？"

🤖 系统:
找到 3 个高适合度片段：

📌 片段1 [02:34 - 03:12, 38秒] ⭐ 适合度: 0.87
   内容: 罗星汉的战略决策失误
   推荐理由: 时长完美(30-60s)、有冲突点、观点明确
   推荐平台: 抖音、快手
   建议标题: "一个错误决策，改变整个格局"

📌 片段2 [05:20 - 06:05, 45秒] ⭐ 适合度: 0.82
   内容: 权力交接的关键时刻
   推荐理由: 有戏剧性、信息密度高
   推荐平台: B站、抖音
   建议标题: "历史转折点：权力如何易主？"

📌 片段3 [08:10 - 08:50, 40秒] ⭐ 适合度: 0.79
   内容: 经济利益驱动的分裂
   推荐理由: 有数据支撑、逻辑清晰
   推荐平台: 知乎、B站
   建议标题: "利益如何撕裂同盟"

💡 后续可以问我：
   • "片段1的完整文本是什么？"
   • "这些片段涉及哪些关键人物？"
   • "有类似主题的其他片段吗？"
```

---

### 场景2: 知识探索（研究者）

**用户故事**:
> 作为一名历史研究者，我想了解视频中不同人物、事件之间的关系，以便构建知识脉络。

**对话示例**:
```
👤 用户: "罗星汉和坤沙是什么关系？"

🤖 系统:
根据知识图谱分析：

🔗 关系类型: 竞争对手 (competitor)
📊 关系强度: 0.78 (强关联)

📝 关系描述:
两人在1970-1980年代是缅北地区的主要权力竞争者。罗星汉控制果敢地区，
坤沙控制金三角核心区域，双方在地盘、资源、政治影响力上存在长期竞争。

🔍 支撑证据:
• [02:45] "罗星汉与坤沙在毒品贸易路线上的冲突..."
• [04:20] "1980年代初，两人的势力范围开始重叠..."
• [06:15] "缅甸政府利用两人的矛盾进行分化..."

🕸️ 相关实体:
• 缅甸政府 (mediator) - 关系强度: 0.65
• 果敢地区 (location) - 罗星汉控制
• 金三角 (location) - 坤沙控制

💡 相关问题:
   • "这种竞争关系如何影响了后续的历史发展？"
   • "视频中还提到了哪些相关人物？"
```

---

### 场景3: 快速理解（学习者）

**用户故事**:
> 作为一名学生，我想快速了解一个长视频的核心内容，而不必观看完整视频。

**对话示例**:
```
👤 用户: "3句话总结这个视频"

🤖 系统:
📊 视频摘要 (基于深度分析):

1️⃣ 核心主题: 缅甸北部地区1960-1990年代的权力结构演变

2️⃣ 关键论点: 罗星汉和坤沙两大势力通过控制毒品贸易和地方武装，
   在缅甸政府弱控制区形成了"双雄并立"的格局

3️⃣ 历史意义: 这种权力格局为后来该地区的持续动荡和复杂局势
   奠定了基础

📈 内容质量评估:
• 信息密度: ⭐⭐⭐⭐☆ (4.2/5.0)
• 逻辑连贯性: ⭐⭐⭐⭐⭐ (4.8/5.0)
• 证据充分性: ⭐⭐⭐⭐☆ (4.0/5.0)

🏷️ 核心标签: #历史 #缅甸 #权力斗争 #毒品贸易 #地缘政治

⏱️ 建议观看: 如果时间有限，重点看 02:30-04:00 和 06:15-07:30
```

---

### 场景4: 多轮深挖（上下文对话）

**对话示例**:
```
👤 用户: "视频中提到了哪些重要事件？"

🤖 系统:
识别到 4 个关键事件：
1. 1960年代果敢地区的割据形成
2. 1970年代罗星汉势力的崛起
3. 1980年代双雄争霸的高峰期
4. 1990年代格局的转变

需要我详细介绍某个事件吗？

---

👤 用户: "详细讲讲第3个"  ⬅️ 保持上下文

🤖 系统:
📅 事件: 1980年代双雄争霸的高峰期

⏱️ 时间跨度: 1980-1989年
📍 涉及地点: 果敢、金三角、缅北边境

📝 详细描述:
[基于原子 #7, #8, #11 的综合分析]
这一时期，罗星汉和坤沙的势力都达到了巅峰状态...
[展开详细叙述，引用具体时间戳]

🔗 相关实体: 罗星汉(主角)、坤沙(主角)、缅甸政府(参与方)

---

👤 用户: "他们后来怎么样了？"  ⬅️ 指代消解

🤖 系统:
理解您在问罗星汉和坤沙的后续发展。

👤 罗星汉:
• 1989年被缅甸政府逮捕
• [时间戳 08:45] 详细描述了被捕经过...

👤 坤沙:
• 1996年向缅甸政府投降
• [时间戳 09:20] 提到了投降的政治背景...
```

---

## 🏗️ 功能规划

### 核心功能模块

#### 1. 查询理解模块 (`query_understanding.py`)

**职责**: 将自然语言查询转换为结构化查询意图

**核心功能**:
- **意图分类**: 识别查询类型（搜索/摘要/关系/推荐/分析）
- **实体提取**: 识别查询中的人物、时间、地点、主题
- **查询改写**: 口语化转规范化（"他后来咋样了" → "查询实体X的后续发展"）
- **上下文融合**: 多轮对话的指代消解和上下文补充

**技术方案**:
- LLM驱动（GPT-4 / Claude）
- Few-shot prompting + 上下文注入
- 输出结构化JSON

**输入示例**:
```json
{
  "query": "他后来怎么样了？",
  "history": [
    {"role": "user", "content": "罗星汉是谁？"},
    {"role": "assistant", "content": "罗星汉是果敢地区的..."}
  ]
}
```

**输出示例**:
```json
{
  "intent": "search_entity_timeline",
  "entities": ["罗星汉"],
  "time_constraint": "after_mentioned",
  "resolved_query": "查询罗星汉在视频后半段的发展情况",
  "confidence": 0.92
}
```

---

#### 2. 混合检索引擎 (`hybrid_retriever.py`)

**职责**: 根据查询意图，组合多种检索策略找到最相关内容

**核心功能**:
- **向量检索**: 基于语义相似度的原子/片段搜索（使用已有的 SemanticSearchEngine）
- **关键词检索**: 精确匹配重要术语
- **图谱查询**: 从知识图谱中提取实体关系
- **过滤器组合**: 实体、主题、时间范围、重要性等多维过滤
- **结果融合**: 多路召回结果的重排序和去重

**检索策略映射**:
```python
RETRIEVAL_STRATEGIES = {
    "search_semantic": ["vector_search", "keyword_match"],
    "search_entity": ["entity_index", "graph_query"],
    "search_relation": ["graph_query", "co_occurrence"],
    "summary": ["narrative_segments", "high_importance_atoms"],
    "recommend_clip": ["creative_angles", "suitability_ranking"],
    "analyze_topic": ["topic_network", "related_atoms"]
}
```

**输入示例**:
```json
{
  "intent": "search_semantic",
  "query": "战略决策失误",
  "filters": {
    "importance_min": 0.7,
    "topics": ["strategy", "decision_making"]
  },
  "top_k": 5
}
```

**输出示例**:
```json
{
  "results": [
    {
      "atom_id": "atom_7",
      "score": 0.89,
      "text": "罗星汉在关键时刻的战略判断失误...",
      "timestamp": "02:45",
      "importance": 0.85,
      "matched_entities": ["罗星汉"],
      "matched_topics": ["strategy"]
    },
    ...
  ],
  "retrieval_time_ms": 120
}
```

---

#### 3. 上下文管理器 (`context_manager.py`)

**职责**: 管理多轮对话的上下文状态

**核心功能**:
- **对话历史**: 保存最近N轮对话（默认10轮）
- **实体追踪**: 记录对话中提到的实体，用于指代消解
- **检索记录**: 避免重复推荐相同内容
- **会话模式**: 探索模式/创作模式/学习模式，影响检索策略

**数据结构**:
```python
class ConversationContext:
    session_id: str
    history: List[Message]  # 对话历史
    focus_entities: Dict[str, int]  # {entity: mention_count}
    retrieved_items: Set[str]  # 已检索的原子/片段ID
    mode: str  # "exploration" | "creation" | "learning"
    video_metadata: Dict  # 当前视频元信息
```

**API示例**:
```python
context.add_turn(query="他后来怎么样了？", response="...")
context.update_focus_entities(["罗星汉"])
context.get_recent_entities(top_n=3)  # 返回最近提到的实体
```

---

#### 4. 响应生成器 (`response_generator.py`)

**职责**: 将检索结果转化为自然语言回答

**核心功能**:
- **答案生成**: 基于检索结果用LLM生成连贯回答
- **引用标注**: 为回答中的每个论断添加证据来源（原子ID + 时间戳）
- **可视化建议**: 推荐时间线/关系图/标签云等可视化方式
- **后续提问**: 基于当前回答生成3-5个推荐问题

**Prompt模板**:
```
你是一个视频内容助手。基于以下检索结果，回答用户问题。

用户问题: {query}
检索结果:
{retrieved_content}

要求:
1. 用自然流畅的语言回答
2. 为每个关键论点标注证据来源 [atom_id, 时间戳]
3. 如果信息不足，明确说明
4. 推荐3个相关的后续问题

回答:
```

**输出结构**:
```json
{
  "answer": "罗星汉在1989年被缅甸政府逮捕...",
  "citations": [
    {"atom_id": "atom_15", "timestamp": "08:45", "text": "..."}
  ],
  "visualization_suggestions": [
    {"type": "timeline", "entities": ["罗星汉"]}
  ],
  "follow_up_questions": [
    "被捕的具体原因是什么？",
    "这对果敢地区有何影响？",
    "坤沙在同一时期的情况如何？"
  ]
}
```

---

#### 5. 数据加载器 (`data_loader.py`)

**职责**: 统一管理对6类数据源的访问

**数据源映射**:
```python
DATA_SOURCES = {
    "atoms": "data/output_pipeline_v3/atoms.jsonl",
    "segments": "data/output_pipeline_v3/narrative_segments.json",
    "entities": "data/output_pipeline_v3/entities.json",
    "topics": "data/output_pipeline_v3/topics.json",
    "graph": "data/output_pipeline_v3/indexes/graph.json",
    "creative": "data/output_pipeline_v3/creative_angles.json",
    "vector_db": "QdrantVectorStore instance"
}
```

**核心功能**:
- 懒加载（按需加载数据）
- 缓存机制（避免重复读取）
- 统一查询接口

**API示例**:
```python
loader = DataLoader(output_dir="data/output_pipeline_v3/")
atoms = loader.get_atoms()  # 返回List[Dict]
entity = loader.get_entity_by_name("罗星汉")  # 返回Dict
relations = loader.get_entity_relations("罗星汉")  # 从图谱查询
```

---

#### 6. 对话接口 (`conversational_interface.py`)

**职责**: 对外的主接口，编排各模块协同工作

**核心流程**:
```python
class ConversationalInterface:
    def chat(self, query: str, session_id: str) -> Response:
        # 1. 加载/创建会话上下文
        context = self.context_manager.get_or_create(session_id)

        # 2. 查询理解
        intent = self.query_understander.parse(query, context)

        # 3. 混合检索
        results = self.retriever.retrieve(intent)

        # 4. 响应生成
        response = self.generator.generate(query, results, context)

        # 5. 更新上下文
        context.add_turn(query, response)

        return response
```

**REST API设计**:
```
POST /api/chat
{
  "query": "这个视频讲什么？",
  "session_id": "sess_12345",  // 可选，不提供则创建新会话
  "options": {
    "mode": "exploration",  // exploration | creation | learning
    "top_k": 5
  }
}

Response:
{
  "answer": "...",
  "citations": [...],
  "follow_up_questions": [...],
  "session_id": "sess_12345"
}
```

---

## 🛠️ 技术架构

### 架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    用户交互层                                 │
│  ┌─────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │  CLI客户端   │  │  Web界面(未来)│  │  API接口     │       │
│  └─────────────┘  └──────────────┘  └──────────────┘       │
└───────────────────────────┬─────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────┐
│              对话编排层 (ConversationalInterface)             │
│                                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  查询理解     │  │  上下文管理   │  │  响应生成     │      │
│  │  (LLM驱动)   │  │  (状态追踪)  │  │  (LLM生成)   │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└───────────────────────────┬─────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────┐
│               检索层 (HybridRetriever)                        │
│                                                               │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐       │
│  │ 向量检索 │  │ 图谱查询 │  │ 关键词   │  │ 过滤排序 │       │
│  │(Qdrant) │  │(Graph)  │  │ 匹配     │  │ (Fusion)│       │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘       │
└───────────────────────────┬─────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────┐
│              数据层 (DataLoader)                              │
│                                                               │
│  ┌──────┐ ┌────────┐ ┌───────┐ ┌───────┐ ┌──────┐         │
│  │Atoms │ │Segments│ │Entities│ │Topics │ │Graph │         │
│  │.jsonl│ │ .json  │ │ .json  │ │ .json │ │.json │         │
│  └──────┘ └────────┘ └───────┘ └───────┘ └──────┘         │
│                                                               │
│  ┌───────────────────┐  ┌──────────────────────┐           │
│  │ CreativeAngles    │  │  Qdrant Vector DB     │           │
│  │     .json         │  │  (Embeddings)         │           │
│  └───────────────────┘  └──────────────────────┘           │
└───────────────────────────────────────────────────────────┘
```

### 技术选型

| 组件 | 技术方案 | 原因 |
|------|---------|------|
| **LLM** | OpenAI GPT-4o-mini | 查询理解+响应生成，成本适中 |
| **向量检索** | Qdrant (已有) | 已集成，性能良好 |
| **Embedding** | text-embedding-3-small (已有) | 已集成，成本低 |
| **数据格式** | JSON/JSONL | 与现有系统兼容 |
| **接口形式** | 命令行 CLI (MVP) | 快速验证，后续扩展Web |
| **上下文存储** | 内存 (MVP) → Redis (生产) | MVP阶段简化，生产环境持久化 |
| **编程语言** | Python 3.9+ | 与现有系统一致 |

### 依赖项（新增）
```
openai>=1.0.0           # 已安装
qdrant-client>=1.7.0    # 已安装
tiktoken>=0.5.0         # 已安装
prompt-toolkit>=3.0.0   # CLI交互（新增）
rich>=13.0.0            # CLI美化输出（新增）
```

---

## 🎯 MVP范围

### MVP目标
> 在命令行环境下，实现基于单个视频的对话式内容查询，验证核心技术方案。

### MVP功能清单

#### ✅ 包含的功能
1. **基础对话**
   - 单轮问答（不依赖上下文）
   - 多轮对话（最多5轮历史）

2. **4类核心查询**
   - 语义搜索: "视频中讲了哪些关于X的内容？"
   - 摘要生成: "总结这个视频"
   - 实体查询: "X是谁？X和Y是什么关系？"
   - 创作推荐: "有哪些适合做短视频的片段？"

3. **检索能力**
   - 向量语义搜索（复用 SemanticSearchEngine）
   - 实体索引查询
   - 知识图谱关系查询
   - 创作角度推荐

4. **输出格式**
   - 自然语言回答
   - 引用来源（原子ID + 时间戳）
   - 后续问题推荐（3个）

#### ❌ 暂不包含（留给后续迭代）
- Web界面
- 跨视频查询
- 对话导出/分享
- 用户认证
- 对话历史持久化
- 复杂的可视化（时间线图、关系图等）
- 语音输入/输出
- 实时视频播放跳转

---

## 📅 开发计划

### 总体时间规划: 3-4天

### 第1天: 基础设施搭建

**任务列表**:
- [ ] 创建项目结构 (`conversational/` 目录)
- [ ] 实现 `DataLoader` - 统一数据加载接口
- [ ] 实现 `ContextManager` - 基础版（内存存储）
- [ ] 编写单元测试

**交付物**:
- `conversational/data_loader.py` (200行)
- `conversational/context_manager.py` (150行)
- `tests/test_data_loader.py`

**验收标准**:
```python
# 能够加载所有6类数据源
loader = DataLoader("data/output_pipeline_v3/")
assert len(loader.get_atoms()) > 0
assert "罗星汉" in loader.get_entity_by_name("罗星汉")["name"]
```

---

### 第2天: 查询理解 + 混合检索

**任务列表**:
- [ ] 实现 `QueryUnderstanding` - LLM驱动的意图识别
- [ ] 实现 `HybridRetriever` - 4种检索策略
- [ ] 编写检索策略单元测试
- [ ] 性能优化（缓存、并发）

**交付物**:
- `conversational/query_understanding.py` (250行)
- `conversational/hybrid_retriever.py` (400行)
- `tests/test_retriever.py`

**验收标准**:
```python
# 能够正确理解查询意图
intent = understander.parse("罗星汉是谁？")
assert intent["intent"] == "search_entity"
assert "罗星汉" in intent["entities"]

# 能够检索到相关内容
results = retriever.retrieve(intent)
assert len(results) > 0
assert results[0]["score"] > 0.7
```

---

### 第3天: 响应生成 + 主流程编排

**任务列表**:
- [ ] 实现 `ResponseGenerator` - LLM生成回答
- [ ] 实现 `ConversationalInterface` - 主编排逻辑
- [ ] 实现 CLI 交互界面（使用 prompt-toolkit）
- [ ] 端到端测试

**交付物**:
- `conversational/response_generator.py` (300行)
- `conversational/interface.py` (350行)
- `conversational/cli.py` (200行)
- `scripts/test_conversational.py`

**验收标准**:
```bash
# 能够运行CLI并完成对话
python scripts/chat_cli.py

> 这个视频讲什么？
[系统返回摘要]

> 罗星汉是谁？
[系统返回实体信息]

> 有适合做短视频的片段吗？
[系统返回推荐列表]
```

---

### 第4天: 优化 + 文档 + 演示

**任务列表**:
- [ ] 性能优化（响应延迟 <3秒）
- [ ] 错误处理完善
- [ ] 编写使用文档
- [ ] 准备演示案例
- [ ] 集成到 `video_processor_v3` (可选)

**交付物**:
- `CONVERSATIONAL_GUIDE.md` - 使用指南
- `DEMO_CASES.md` - 演示案例集
- 性能报告

**验收标准**:
- 平均响应时间 <3秒
- 意图识别准确率 >85%（手动测试20个查询）
- 无致命bug
- 文档完整可读

---

### 开发里程碑

| 里程碑 | 日期 | 标志 |
|--------|------|------|
| **M1: 数据层就绪** | Day 1 | 所有数据源可访问 |
| **M2: 检索能力验证** | Day 2 | 4种查询类型可用 |
| **M3: MVP可用** | Day 3 | CLI可交互对话 |
| **M4: 生产就绪** | Day 4 | 文档+演示完成 |

---

## 📊 成功指标

### 功能指标
- [ ] 支持4类核心查询（搜索/摘要/实体/推荐）
- [ ] 多轮对话上下文保持（至少5轮）
- [ ] 引用溯源准确率 100%

### 性能指标
- [ ] 平均响应延迟 <3秒
- [ ] 向量检索召回率 >80% (top-5)
- [ ] 意图识别准确率 >85%

### 用户体验指标
- [ ] 回答自然流畅（人工评估）
- [ ] 引用格式清晰易懂
- [ ] 后续问题推荐相关性高

### 成本指标
- [ ] 单次对话成本 <$0.01 (基于GPT-4o-mini)
- [ ] 单视频处理总成本 <$0.05

---

## ⚠️ 风险评估

### 技术风险

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| **LLM输出不稳定** | 意图识别错误 | 中 | Few-shot示例+重试机制 |
| **检索召回不足** | 答非所问 | 中 | 混合检索+阈值调整 |
| **响应延迟过高** | 用户体验差 | 低 | 并发检索+结果缓存 |
| **上下文理解错误** | 多轮对话失败 | 中 | 显式实体追踪+消歧提问 |

### 产品风险

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| **用户期望过高** | 失望 | 高 | 明确MVP范围，设定合理期望 |
| **单视频限制** | 场景受限 | 中 | 后续版本支持跨视频 |
| **CLI交互门槛** | 采用率低 | 中 | 提供丰富示例+后续推出Web版 |

### 资源风险

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| **API费用超预算** | 成本失控 | 低 | 使用GPT-4o-mini+设置调用上限 |
| **开发时间不足** | 功能缩水 | 中 | 严格MVP范围+模块化设计 |

---

## 🔄 后续迭代方向

### Phase 2 单元3 v2.0 (未来)
- Web界面（React + Flask API）
- 对话历史持久化（SQLite/PostgreSQL）
- 可视化组件（时间线图、关系图、标签云）
- 语音输入/输出
- 对话导出（Markdown/PDF）

### Phase 3 应用层集成
- 跨视频查询（"在我的所有视频中找..."）
- 批量分析（"比较这5个视频的主题分布"）
- 创作工作台（视频剪辑建议+脚本生成）
- 插件系统（自定义查询策略）

---

## 📚 参考资料

### 相关技术文档
- OpenAI API: https://platform.openai.com/docs/api-reference
- Qdrant文档: https://qdrant.tech/documentation/
- prompt-toolkit: https://python-prompt-toolkit.readthedocs.io/

### 现有系统文档
- `SESSION_RESUME.md` - Phase 2 总体进展
- `PROJECT_STATUS.md` - 项目暂停报告
- `video_processor_v3.py` - 主Pipeline实现

### RAG系统设计参考
- LangChain Conversational RAG
- LlamaIndex Chat Engines
- Anthropic Claude Context Management

---

## 🎉 总结

本规划文档定义了 **Phase 2 单元3 - AI对话系统** 的完整产品和技术方案：

✅ **核心价值**: 将静态结构化数据转化为可对话的知识助手
✅ **用户场景**: 覆盖创作者/研究者/学习者的核心需求
✅ **技术架构**: 6模块分层设计，可扩展、可维护
✅ **MVP范围**: 4天交付CLI可用版本，验证核心能力
✅ **风险可控**: 明确的缓解措施，合理的预期管理

**下一步行动**:
1. 评审本规划文档
2. 确认技术选型和MVP范围
3. 开始Day 1开发任务

---

**文档维护**: 随开发进展更新，记录重要决策和变更
**版本历史**: v1.0 (2025-10-03) - 初始版本

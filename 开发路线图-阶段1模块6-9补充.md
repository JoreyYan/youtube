# 阶段1 模块1.6-1.9 详细实现

继续 `开发路线图-详细实施计划.md` 的内容...

---

## 模块1.6-1.9 完整实现

### 模块1.6：原子化质量验证器（续）

#### 测试

```python
# tests/test_validator.py

from parsers import SRTParser, Cleaner
from atomizers import Atomizer, AtomValidator
from utils import load_jsonl, setup_logger
from models import Atom
from config import CLAUDE_API_KEY

logger = setup_logger(__name__)

def test_validator():
    """测试验证器"""
    print("\n" + "="*60)
    print("测试原子化质量验证器")
    print("="*60)

    # 加载已生成的原子
    try:
        atoms = load_jsonl("data/processed/atoms_10min.jsonl", Atom)
    except FileNotFoundError:
        print("❌ 请先运行 test_atomizer.py 生成原子数据")
        return

    # 加载原始字幕
    parser = SRTParser()
    utterances = parser.parse("data/raw/test.srt")
    cleaner = Cleaner()
    utterances = cleaner.clean(utterances)
    utterances_10min = [u for u in utterances if u.start_ms < 600000]

    # 验证
    validator = AtomValidator()
    report = validator.validate(atoms, utterances_10min)

    # 打印报告
    validator.print_report(report)

    # 保存报告
    from utils import save_json
    save_json(report, "data/processed/validation_report.json")
    print("\n✓ 报告已保存到 data/processed/validation_report.json")

    return report

if __name__ == "__main__":
    report = test_validator()
```

#### 运行测试

```bash
python tests/test_validator.py
```

#### 验收标准

```
✅ 验证器能正常运行
✅ 能检测出时间覆盖率问题
✅ 能检测出时间间隔问题
✅ 能检测出类型分布异常
✅ 生成的报告清晰可读
✅ 质量评分合理
```

**人工判断**:
```
根据验证报告决定：
- 质量评分 A/B → 进入下一模块
- 质量评分 C → 调整提示词，重新测试
- 质量评分 D → 检查代码逻辑，修复bug
```

---

### 模块1.7：集成测试（1小时）

#### 任务
测试完整流程：SRT解析 → 清洗 → 原子化 → 验证

#### 步骤

**Step 1: 创建集成测试脚本**

```python
# tests/test_integration.py

"""
集成测试：完整的原子化流程

流程：
1. 解析SRT文件
2. 清洗字幕
3. 原子化处理
4. 质量验证
5. 保存结果
"""

from parsers import SRTParser, Cleaner
from atomizers import Atomizer, AtomValidator
from utils import save_jsonl, save_json, setup_logger
from config import CLAUDE_API_KEY
import time

logger = setup_logger(__name__)

def run_integration_test(
    srt_file: str,
    output_prefix: str,
    time_limit_ms: int = 600000,  # 默认10分钟
    batch_size: int = 50
):
    """
    运行完整的集成测试

    Args:
        srt_file: SRT文件路径
        output_prefix: 输出文件前缀
        time_limit_ms: 处理时长限制（毫秒）
        batch_size: 批处理大小
    """
    print("\n" + "="*60)
    print("集成测试 - 完整原子化流程")
    print("="*60)

    start_time = time.time()

    # ========== Step 1: 解析SRT ==========
    print("\n[1/5] 解析SRT文件...")
    parser = SRTParser()
    utterances = parser.parse(srt_file)
    print(f"  ✓ 解析完成：{len(utterances)}条字幕")

    # ========== Step 2: 清洗 ==========
    print("\n[2/5] 清洗字幕...")
    cleaner = Cleaner()
    utterances_clean = cleaner.clean(utterances)
    print(f"  ✓ 清洗完成：{len(utterances_clean)}条（移除{cleaner.removed_count}条）")

    # 截取指定时长
    utterances_limited = [u for u in utterances_clean if u.start_ms < time_limit_ms]
    print(f"  ✓ 截取前{time_limit_ms/60000:.1f}分钟：{len(utterances_limited)}条")

    # ========== Step 3: 原子化 ==========
    print("\n[3/5] 原子化处理...")
    atomizer = Atomizer(CLAUDE_API_KEY, batch_size=batch_size)
    atoms = atomizer.atomize(utterances_limited)
    print(f"  ✓ 原子化完成：{len(atoms)}个原子")

    # API统计
    stats = atomizer.client.get_stats()
    print(f"  API调用: {stats['total_calls']}次")
    print(f"  预估成本: {stats['estimated_cost']}")

    # ========== Step 4: 质量验证 ==========
    print("\n[4/5] 质量验证...")
    validator = AtomValidator()
    report = validator.validate(atoms, utterances_limited)
    validator.print_report(report)

    # ========== Step 5: 保存结果 ==========
    print("\n[5/5] 保存结果...")

    atoms_file = f"data/processed/{output_prefix}_atoms.jsonl"
    report_file = f"data/processed/{output_prefix}_report.json"
    stats_file = f"data/processed/{output_prefix}_stats.json"

    save_jsonl(atoms, atoms_file)
    save_json(report, report_file)
    save_json(stats, stats_file)

    print(f"  ✓ 原子数据: {atoms_file}")
    print(f"  ✓ 验证报告: {report_file}")
    print(f"  ✓ API统计: {stats_file}")

    # ========== 总结 ==========
    elapsed_time = time.time() - start_time
    print("\n" + "="*60)
    print("集成测试完成")
    print("="*60)
    print(f"总耗时: {elapsed_time:.1f}秒")
    print(f"质量评分: {report['quality_score']}")
    print(f"预估成本: {stats['estimated_cost']}")

    # 决策建议
    if report['quality_score'] in ['优秀 (A)', '良好 (B)']:
        print("\n✅ 质量达标，可以进入下一阶段！")
    elif report['quality_score'] == '合格 (C)':
        print("\n⚠️  质量一般，建议优化提示词后重试")
    else:
        print("\n❌ 质量不合格，必须修复问题后重试")

    return atoms, report, stats

if __name__ == "__main__":
    import sys

    if not CLAUDE_API_KEY:
        print("❌ 未配置CLAUDE_API_KEY")
        sys.exit(1)

    # 运行集成测试（前10分钟）
    atoms, report, stats = run_integration_test(
        srt_file="data/raw/test.srt",
        output_prefix="test_10min",
        time_limit_ms=600000,  # 10分钟
        batch_size=50
    )
```

#### 运行测试

```bash
python tests/test_integration.py
```

#### 预期输出

```
============================================================
集成测试 - 完整原子化流程
============================================================

[1/5] 解析SRT文件...
  ✓ 解析完成：3580条字幕

[2/5] 清洗字幕...
  ✓ 清洗完成：3200条（移除380条）
  ✓ 截取前10.0分钟：1850条

[3/5] 原子化处理...
处理批次 1/37...
  ✓ 生成12个原子
...
  ✓ 原子化完成：145个原子
  API调用: 37次
  预估成本: $4.20

[4/5] 质量验证...
============================================================
原子化质量验证报告
============================================================
总原子数: 145
时间覆盖率: 94.2%
质量评分: 良好 (B)
...

[5/5] 保存结果...
  ✓ 原子数据: data/processed/test_10min_atoms.jsonl
  ✓ 验证报告: data/processed/test_10min_report.json
  ✓ API统计: data/processed/test_10min_stats.json

============================================================
集成测试完成
============================================================
总耗时: 180.5秒
质量评分: 良好 (B)
预估成本: $4.20

✅ 质量达标，可以进入下一阶段！
```

#### 验收标准

```
✅ 完整流程能跑通
✅ 所有步骤正常执行
✅ 质量评分达到B或以上
✅ API成本在可接受范围内（<$5/10分钟）
✅ 输出文件都正确生成
✅ 处理时间合理（<5分钟实际处理时间）
```

---

### 模块1.8：提示词优化（1-2小时）

#### 任务
根据验证结果，迭代优化原子化提示词

#### 步骤

**Step 1: 分析问题**

```python
# scripts/analyze_atoms.py

"""
分析原子化结果，找出常见问题
"""

from utils import load_jsonl
from models import Atom
from collections import Counter

def analyze_atoms(atoms_file: str):
    """分析原子化结果"""
    atoms = load_jsonl(atoms_file, Atom)

    print("\n" + "="*60)
    print("原子化结果分析")
    print("="*60)

    # 统计1: 原子长度分布
    lengths = [a.duration_seconds for a in atoms]
    print(f"\n长度统计:")
    print(f"  平均: {sum(lengths)/len(lengths):.1f}秒")
    print(f"  最短: {min(lengths):.1f}秒")
    print(f"  最长: {max(lengths):.1f}秒")
    print(f"  中位数: {sorted(lengths)[len(lengths)//2]:.1f}秒")

    # 找出异常短的原子
    very_short = [a for a in atoms if a.duration_seconds < 5]
    if very_short:
        print(f"\n⚠️  过短原子 (<5秒): {len(very_short)}个")
        for a in very_short[:3]:
            print(f"  {a.atom_id}: {a.merged_text[:50]}")

    # 找出异常长的原子
    very_long = [a for a in atoms if a.duration_seconds > 600]
    if very_long:
        print(f"\n⚠️  过长原子 (>10分钟): {len(very_long)}个")
        for a in very_long[:3]:
            print(f"  {a.atom_id}: {a.merged_text[:50]}")

    # 统计2: 类型分布
    type_counter = Counter(a.type for a in atoms)
    print(f"\n类型分布:")
    for t, count in type_counter.most_common():
        print(f"  {t}: {count}个 ({count/len(atoms)*100:.1f}%)")

    # 检查类型多样性
    if len(type_counter) < 3:
        print(f"\n⚠️  类型多样性不足（只有{len(type_counter)}种类型）")

    # 统计3: 完整性分布
    completeness_counter = Counter(a.completeness for a in atoms)
    print(f"\n完整性分布:")
    for c, count in completeness_counter.most_common():
        print(f"  {c}: {count}个 ({count/len(atoms)*100:.1f}%)")

    # 统计4: 完整片段
    complete_segments = [a for a in atoms if a.type == "complete_segment"]
    print(f"\n完整片段: {len(complete_segments)}个")
    if complete_segments:
        print("示例:")
        for a in complete_segments[:2]:
            print(f"  {a.atom_id} ({a.duration_seconds/60:.1f}分钟): {a.merged_text[:60]}...")

    # 统计5: 边界检查（相邻原子的主题变化）
    print(f"\n边界合理性检查（随机抽样）:")
    import random
    samples = random.sample(range(1, len(atoms)-1), min(5, len(atoms)-2))
    for i in samples:
        prev_atom = atoms[i-1]
        curr_atom = atoms[i]
        print(f"\n  边界 {i}:")
        print(f"    前: [{prev_atom.type}] {prev_atom.merged_text[-40:]}")
        print(f"    后: [{curr_atom.type}] {curr_atom.merged_text[:40]}")

if __name__ == "__main__":
    analyze_atoms("data/processed/test_10min_atoms.jsonl")
```

**Step 2: 根据分析结果调整提示词**

根据常见问题，创建优化版本：

```
# prompts/atomize_v2.txt

（根据实际问题修改）

例如，如果发现：
- 问题1: 边界切分过细 → 强调"语义完整"
- 问题2: 类型判断不准 → 增加类型定义和示例
- 问题3: 完整片段识别不足 → 强化complete_segment的判断标准

示例优化版本：

你是一个视频内容分析专家。我会给你一段直播的字幕片段，你的任务是把它们合并成"语义完整的信息单元"。

【核心规则 - 加强版】

1. 原子长度灵活：
   - 短：10-30秒（单次互动、简短评论）
   - 中：1-5分钟（完整观点、小故事、完整回应）
   - 长：5-15分钟（完整历史叙述、深度论述）

   ⚠️ 重要：不要为了统一长度而强行切分！语义完整性优先！

2. 边界判断标准（更严格）：
   - 主题明确转换（不是细微变化）→ 新原子
   - 长时间停顿（>8秒）→ 新原子
   - 明确的话题转换词（"那我们说点别的"、"好，下一个问题"）→ 新原子
   - 从叙事转到互动（或反向）→ 新原子

   ⚠️ 不要因为小的停顿就切分！保持语义连贯性！

3. 完整片段识别（complete_segment）- 加强标准：
   必须同时满足：
   ✅ 时长 ≥ 5分钟
   ✅ 主题高度统一（围绕一个核心话题）
   ✅ 有清晰的开始和结束
   ✅ 逻辑完整（背景-发展-结论 或 观点-论据-总结）
   ✅ 可以独立作为一个视频片段使用

   如果只满足部分条件 → 标记为 type: "fragment"

4. 类型分类（更细致）：
   - 叙述历史：讲述具体历史事件，有时间、人物、事件
   - 分析观点：表达看法、分析原因、评价事件
   - 回应弹幕：直接回应观众提问或评论
   - 读观众来信：朗读并回应观众信件
   - 闲聊互动：轻松聊天、无关主题的互动
   - 引入话题：开场白、过渡语、话题引入

   ⚠️ 注意区分"叙述事实"和"发表观点"！

【输出格式】
JSON数组，每个元素包含：
{
  "atom_id": "A001",
  "start_ms": 500000,
  "end_ms": 510000,
  "duration_ms": 10000,
  "merged_text": "完整的合并文本",
  "type": "叙述历史",  // 使用上述6种类型之一
  "completeness": "完整",  // 或"需要上下文"
  "source_utterance_ids": [1,2,3]
}

【质量自检】
在输出之前，请确认：
✅ 没有把一句完整的话切成两个原子
✅ 类型判断基于内容，不是基于长度
✅ 完整片段真的可以独立理解
✅ 时间连续，没有遗漏
✅ atom_id 连续编号
```

**Step 3: A/B测试**

```python
# scripts/compare_prompts.py

"""
对比不同提示词版本的效果
"""

from atomizers import Atomizer
from parsers import SRTParser, Cleaner
from utils import save_jsonl
from config import CLAUDE_API_KEY

def test_prompt_version(prompt_file: str, output_file: str):
    """测试指定提示词版本"""
    # 解析字幕
    parser = SRTParser()
    utterances = parser.parse("data/raw/test.srt")

    cleaner = Cleaner()
    utterances = cleaner.clean(utterances)
    utterances = [u for u in utterances if u.start_ms < 600000]  # 前10分钟

    # 原子化（使用指定提示词）
    atomizer = Atomizer(CLAUDE_API_KEY, batch_size=50)

    # 替换提示词
    with open(prompt_file, 'r', encoding='utf-8') as f:
        atomizer.prompt_template = f.read()

    atoms = atomizer.atomize(utterances)

    # 保存
    save_jsonl(atoms, output_file)

    # 返回统计
    stats = atomizer.client.get_stats()
    return atoms, stats

if __name__ == "__main__":
    print("测试 v1 提示词...")
    atoms_v1, stats_v1 = test_prompt_version(
        "prompts/atomize_v1.txt",
        "data/processed/atoms_v1.jsonl"
    )

    print("\n测试 v2 提示词...")
    atoms_v2, stats_v2 = test_prompt_version(
        "prompts/atomize_v2.txt",
        "data/processed/atoms_v2.jsonl"
    )

    print("\n对比结果:")
    print(f"v1: {len(atoms_v1)}个原子, {stats_v1['estimated_cost']}")
    print(f"v2: {len(atoms_v2)}个原子, {stats_v2['estimated_cost']}")

    # 运行分析对比
    print("\n" + "="*60)
    print("v1 分析:")
    from scripts.analyze_atoms import analyze_atoms
    analyze_atoms("data/processed/atoms_v1.jsonl")

    print("\n" + "="*60)
    print("v2 分析:")
    analyze_atoms("data/processed/atoms_v2.jsonl")
```

#### 验收标准

```
✅ 能识别出质量问题
✅ 针对性地调整提示词
✅ 新版本质量有提升
✅ 迭代2-3次后达到A或B评分
```

---

### 模块1.9：全视频测试（2-3小时）

#### 任务
在完整2小时视频上测试，验证可扩展性

#### 步骤

**Step 1: 创建全视频测试脚本**

```python
# scripts/process_full_video.py

"""
处理完整视频（2小时）
"""

from tests.test_integration import run_integration_test
from config import CLAUDE_API_KEY
import sys

def process_full_video():
    """处理完整视频"""
    if not CLAUDE_API_KEY:
        print("❌ 未配置CLAUDE_API_KEY")
        sys.exit(1)

    # 询问用户确认
    print("\n⚠️  警告：处理2小时视频可能需要：")
    print("   - 时间: 20-40分钟")
    print("   - 成本: $40-60")
    print("   - API调用: 400-500次")

    confirm = input("\n确认继续？(yes/no): ")
    if confirm.lower() != 'yes':
        print("已取消")
        return

    # 运行完整处理
    atoms, report, stats = run_integration_test(
        srt_file="data/raw/test.srt",
        output_prefix="full_video",
        time_limit_ms=7200000,  # 2小时
        batch_size=50
    )

    # 额外分析
    print("\n" + "="*60)
    print("完整视频处理结果分析")
    print("="*60)

    # 完整片段统计
    complete_segments = [a for a in atoms if a.type == "complete_segment"]
    print(f"\n完整片段: {len(complete_segments)}个")
    if complete_segments:
        total_complete_duration = sum(a.duration_ms for a in complete_segments) / 1000
        print(f"完整片段总时长: {total_complete_duration/60:.1f}分钟")
        print(f"占比: {total_complete_duration/7200*100:.1f}%")

    # 类型时长分布
    type_durations = {}
    for atom in atoms:
        if atom.type not in type_durations:
            type_durations[atom.type] = 0
        type_durations[atom.type] += atom.duration_ms / 1000

    print(f"\n各类型时长占比:")
    for t, duration in sorted(type_durations.items(), key=lambda x: -x[1]):
        print(f"  {t}: {duration/60:.1f}分钟 ({duration/7200*100:.1f}%)")

    return atoms, report, stats

if __name__ == "__main__":
    process_full_video()
```

**Step 2: 性能监控**

```python
# utils/progress.py

"""
进度监控工具
"""

from rich.progress import Progress, SpinnerColumn, TimeElapsedColumn, BarColumn, TextColumn

class ProgressMonitor:
    """处理进度监控器"""

    def __init__(self):
        self.progress = None
        self.task = None

    def __enter__(self):
        self.progress = Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
            TimeElapsedColumn(),
        )
        self.progress.start()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.progress:
            self.progress.stop()

    def add_task(self, description: str, total: int):
        """添加任务"""
        self.task = self.progress.add_task(description, total=total)
        return self.task

    def update(self, advance: int = 1):
        """更新进度"""
        if self.progress and self.task is not None:
            self.progress.update(self.task, advance=advance)
```

修改 Atomizer 类以支持进度监控：

```python
# atomizers/atomizer.py (更新)

# 在 atomize 方法中添加进度支持
def atomize(
    self,
    utterances: List[Utterance],
    start_atom_id: int = 1,
    show_progress: bool = True
) -> List[Atom]:
    """原子化处理（带进度条）"""
    atoms = []
    total_batches = (len(utterances) + self.batch_size - 1) // self.batch_size
    atom_counter = start_atom_id

    logger.info(f"开始原子化，共{len(utterances)}条字幕，分{total_batches}批处理")

    if show_progress:
        from utils.progress import ProgressMonitor
        with ProgressMonitor() as monitor:
            monitor.add_task("原子化处理中...", total=total_batches)

            for i in range(0, len(utterances), self.batch_size):
                batch = utterances[i:i + self.batch_size]
                try:
                    batch_atoms = self._process_batch(batch, atom_counter)
                    atoms.extend(batch_atoms)
                    atom_counter += len(batch_atoms)
                    monitor.update(1)
                except Exception as e:
                    logger.error(f"批次处理失败: {e}")
                    monitor.update(1)
                    continue
    else:
        # 原有逻辑
        for i in range(0, len(utterances), self.batch_size):
            batch = utterances[i:i + self.batch_size]
            batch_num = i // self.batch_size + 1
            logger.info(f"处理批次 {batch_num}/{total_batches}...")
            try:
                batch_atoms = self._process_batch(batch, atom_counter)
                atoms.extend(batch_atoms)
                atom_counter += len(batch_atoms)
                logger.info(f"  ✓ 生成{len(batch_atoms)}个原子")
            except Exception as e:
                logger.error(f"  ✗ 批次{batch_num}处理失败: {e}")
                continue

    self.total_atoms = len(atoms)
    logger.info(f"原子化完成，共生成{self.total_atoms}个原子")

    return atoms
```

#### 运行测试

```bash
python scripts/process_full_video.py
```

#### 预期输出

```
⚠️  警告：处理2小时视频可能需要：
   - 时间: 20-40分钟
   - 成本: $40-60
   - API调用: 400-500次

确认继续？(yes/no): yes

============================================================
集成测试 - 完整原子化流程
============================================================

[1/5] 解析SRT文件...
  ✓ 解析完成：14320条字幕

[2/5] 清洗字幕...
  ✓ 清洗完成：12800条（移除1520条）
  ✓ 截取前120.0分钟：12800条

[3/5] 原子化处理...
原子化处理中... ████████████████████ 100% 00:25:30
  ✓ 原子化完成：580个原子
  API调用: 256次
  预估成本: $48.50

[4/5] 质量验证...
============================================================
原子化质量验证报告
============================================================
总原子数: 580
时间覆盖率: 92.8%
质量评分: 良好 (B)

长度分布:
  short_(<30s): 120
  medium_(30s-5min): 425
  long_(>5min): 35
  avg_seconds: 124.8
  max_seconds: 890.0
  min_seconds: 8.5

类型分布:
  叙述历史: 285
  回应弹幕: 178
  分析观点: 82
  闲聊互动: 25
  读观众来信: 8
  引入话题: 2

时间间隔 (>30秒): 15个
  ...

⚠️  警告 (2个):
  - 时间覆盖率偏低: 92.8% (建议>95%)
  - 时间间隔过多: 15个大间隔 (>10%)

============================================================

[5/5] 保存结果...
  ✓ 原子数据: data/processed/full_video_atoms.jsonl
  ✓ 验证报告: data/processed/full_video_report.json
  ✓ API统计: data/processed/full_video_stats.json

============================================================
集成测试完成
============================================================
总耗时: 1850.5秒
质量评分: 良好 (B)
预估成本: $48.50

✅ 质量达标，可以进入下一阶段！

============================================================
完整视频处理结果分析
============================================================

完整片段: 12个
完整片段总时长: 85.5分钟
占比: 71.2%

各类型时长占比:
  叙述历史: 68.5分钟 (57.1%)
  回应弹幕: 28.2分钟 (23.5%)
  分析观点: 15.8分钟 (13.2%)
  闲聊互动: 5.2分钟 (4.3%)
  读观众来信: 1.8分钟 (1.5%)
  引入话题: 0.5分钟 (0.4%)
```

#### 验收标准

```
✅ 能成功处理完整2小时视频
✅ 处理时间<40分钟
✅ API成本<$60
✅ 质量评分达到B或以上
✅ 没有内存溢出或崩溃
✅ 完整片段识别率合理（至少识别出5-10个）
✅ 完整片段占比合理（50-80%）
```

**人工验收**:
```
随机抽样20个原子进行人工检查：
✅ 边界合理（90%+）
✅ 类型准确（85%+）
✅ 文本完整（95%+）
✅ 完整片段判断合理（80%+）
```

**抽样检查脚本**:

```python
# scripts/manual_review.py

"""
人工审核辅助工具
"""

from utils import load_jsonl
from models import Atom
import random

def random_sample_review(atoms_file: str, sample_size: int = 20):
    """随机抽样原子进行人工审核"""
    atoms = load_jsonl(atoms_file, Atom)

    # 随机抽样
    samples = random.sample(atoms, min(sample_size, len(atoms)))

    print("\n" + "="*60)
    print(f"人工审核 - 随机抽样{len(samples)}个原子")
    print("="*60)

    for i, atom in enumerate(samples, 1):
        print(f"\n【原子 {i}/{len(samples)}】")
        print(f"ID: {atom.atom_id}")
        print(f"时间: {atom.start_time} - {atom.end_time} ({atom.duration_seconds:.1f}秒)")
        print(f"类型: {atom.type}")
        print(f"完整性: {atom.completeness}")
        print(f"文本: {atom.merged_text}")
        print("\n" + "-"*60)

        # 等待人工评分
        print("请评价：")
        print("1 - 边界合理？(y/n)")
        print("2 - 类型准确？(y/n)")
        print("3 - 文本完整？(y/n)")
        print("4 - 完整性判断合理？(y/n)")
        print("输入评分（如：y,y,y,n）或按Enter跳过：")

        rating = input("> ")
        if rating:
            # 保存评分结果
            pass

    print("\n审核完成！")

if __name__ == "__main__":
    random_sample_review("data/processed/full_video_atoms.jsonl", 20)
```

---

## 🎯 阶段1总结

**完成标准**:

```
模块1.1 ✅ 项目初始化
模块1.2 ✅ 数据模型定义
模块1.3 ✅ SRT解析器
模块1.4 ✅ 工具函数
模块1.5 ✅ 原子化提示词
模块1.6 ✅ 质量验证器
模块1.7 ✅ 集成测试
模块1.8 ✅ 提示词优化
模块1.9 ✅ 全视频测试
```

**交付物**:

```
1. 代码
   ├─ parsers/ (SRT解析和清洗)
   ├─ atomizers/ (原子化和验证)
   ├─ models/ (数据模型)
   ├─ utils/ (工具函数)
   ├─ tests/ (测试脚本)
   ├─ scripts/ (分析和处理脚本)
   ├─ prompts/ (提示词版本)
   └─ config.py

2. 数据
   ├─ test_10min_atoms.jsonl (10分钟原子数据)
   ├─ full_video_atoms.jsonl (完整视频原子数据)
   ├─ validation_report.json (质量报告)
   └─ api_stats.json (成本统计)

3. 文档
   ├─ 质量评分报告
   ├─ API成本统计
   ├─ 常见问题和解决方案
   └─ 人工审核结果
```

**关键指标**:

```
✅ 原子化准确率: >85%
✅ 时间覆盖率: >90%
✅ API成本: <$60/2小时视频
✅ 处理时间: <40分钟/2小时视频
✅ 质量评分: B或以上
✅ 完整片段识别: 5-15个/2小时视频
```

**风险缓解**:

```
✅ 提示词迭代机制已建立
✅ 质量验证自动化完成
✅ 成本控制在预算内
✅ 处理时间可接受
✅ 可扩展性已验证
```

---

## 🚀 进入阶段2的条件

只有当以下所有条件满足时，才能进入阶段2：

```
□ 10分钟测试质量评分 ≥ B
□ 完整视频质量评分 ≥ B
□ API成本 < $60/2小时
□ 人工抽样准确率 > 85%
□ 所有测试脚本通过
□ 代码提交到版本控制
```

---

## 📋 阶段2预告

验收通过后，进入阶段2：**语义分析层**

```
阶段2：语义分析层（5-7天）

模块2.1: 主题分析器（1天）
  - 识别每个原子的主题标签
  - 提取关键实体（人物、地点、事件）

模块2.2: 情感分析器（1天）
  - 情感倾向（正面/中性/负面）
  - 情感强度

模块2.3: 价值评估器（1天）
  - 内容价值（教育/娱乐/争议）
  - 重要性打分

模块2.4: 向量化（1天）
  - OpenAI embeddings生成
  - 批量处理优化

模块2.5: 向量索引（1天）
  - Chromadb集成
  - 语义搜索测试

模块2.6: 语义搜索（1天）
  - 跨原子搜索
  - 相似度计算

模块2.7: 相关性计算（半天）
  - 原子间关联
  - 主题聚类

模块2.8: 完整处理流水线（半天）
  - 端到端集成
  - 性能优化
```

---

**当前状态**: 阶段1路线图完整制定完毕

**下一步**: 等待你的指示，开始实施或调整路线图
